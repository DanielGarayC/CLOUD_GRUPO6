
# Este archivo YA se carga dentro de http { } por el Nginx base

server {
    listen 80;

    #C aceptan peticiones de cualquier origen
            #En producción deberiamos limitarlo a de donde proviene el frontend
            #Por ejemplo http:localhost:3000 si ese es el puerto expuesto del front
            add_header Access-Control-Allow-Origin  * always;
            #Se acepta contenido de tipo JSON y autorización en el header
            add_header Access-Control-Allow-Headers Authorization,Content-Type always;
            #Se aceptan métodos como GET, POST, PUT, DELETE y OPTIONS 
            add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS always;

    #Cabeceras para que el backend sepa quien está iniciando la petición
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    #Login sin autenticación
    location /api/auth/ {
        #Recordar que al estar en docker-compose, usamos el nombre del
        #servicio como hostname y no localhost :D
        proxy_pass: http://auth:8080/login;
    }

    # Verificación de token para todas las demás rutas
    location = /_auth_check {
        internal; # Para manejar internamente este chequeo (no está expuesto esto al usuario)
        proxy_pass: http://auth:8080/verify;
        proxy_pass_request_body off; # No necesitamos el cuerpo de la petición, solo verificamos
        proxy_set_header Content-Length ""; # No enviamos cuerpo
        proxy_set_header Authorization $http_authorization; # Pasamos el Bearer token para verificar
        proxy_set_header X-Original-URI $request_uri; # Pasamos la URI original para que el servicio de auth pueda usarla si es necesario (no c usa)
    }

    # Rutas privadas owo
    #Slice Manager
    location /api/sliceManager/ {
        auth_request /_auth_check; # Valida el token con _auth_check
        #Si de verdad ta autorizada, pasa a la sgte ruta
        proxy_pass http://sliceManager:5001/; 
    }

    location /api/userService/ {
        auth_request /_auth_check; # Valida el token con _auth_check
        #Si de verdad ta autorizada, pasa a la sgte ruta
        proxy_pass http://userService:5002/; 
    }

    location /api/monitoring/ {
        auth_request /_auth_check; # Valida el token con _auth_check
        #Si de verdad ta autorizada, pasa a la sgte ruta
        proxy_pass http://resources:5003/;
    }


    error_page 401 403 = @auth_error;
    location @auth_error { return 401 "Unauthorized"; }
}
}